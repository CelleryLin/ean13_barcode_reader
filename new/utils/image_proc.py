if __name__ == '__main__':
    import sys
    from PyQt5 import QtWidgets
    QtWidgets.QApplication(sys.argv)


import numpy as np
import cv2
import utils.function as f
from tqdm import tqdm
import torch
import matplotlib.pyplot as plt
import seaborn as sns
import math

def scurve(x, a):
    # 3 order polynomial passing through (0,0), (0.5,0.5), (1,1)
    # 0<=x<=1
    # 2>=a>=-2

    if x < 0:
        return 0
    elif x > 1:
        return 1
    else:
        d = 0
        b = a*(-3/2)
        c = 1+(0.5*a)
        return a*(x**3) + b*(x**2) + c*x + d
    
def normalize(img):
    img = img/np.max(img)
    return img


def contrast(img, a):
    # -1<=a<=1
    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
            img[i,j] = scurve(img[i,j], a*-2)
    return img


def binarize(img, threshold):
    img[img < threshold] = 0
    img[img >= threshold] = 1
    return img

def median_blur(img, ksize):
    if ksize % 2 == 0:
        ksize += 1
    img = np.pad(img, pad_width=ksize//2, mode='constant', constant_values=0)
    for i in range(ksize//2, img.shape[0]-ksize//2):
        for j in range(ksize//2, img.shape[1]-ksize//2):
            img[i,j] = np.median(img[i-ksize//2:i+ksize//2+1, j-ksize//2:j+ksize//2+1])
    return img[ksize//2:-ksize//2, ksize//2:-ksize//2]

def gaussian_blur(img):
    device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
    kernel = np.array([[1, 2, 1],
                       [2, 4, 2],
                       [1, 2, 1]])
    kernel = kernel/np.sum(kernel)

    img = torch.from_numpy(img).float().to(device)
    kernel = torch.from_numpy(kernel).float().to(device)

    img = img.unsqueeze(0).unsqueeze(0)
    kernel = kernel.unsqueeze(0).unsqueeze(0)

    img_blur = torch.nn.functional.conv2d(img, kernel, padding=1)
    img_blur = img_blur.squeeze(0).squeeze(0).cpu().numpy()
    return img_blur


def adaptive_binarize(img, ksize=(100, 100), th_shift=0):
    H, W = img.shape

    # split image into 100x100 blocks
    image_new = np.zeros((H, W))
    for i in range(0, H, ksize[0]):
        for j in range(0, W, ksize[1]):
            th = get_best_threshold(img[i:i+ksize[0], j:j+ksize[1]])
            th += th_shift
            image_new[i:i+ksize[0], j:j+ksize[1]] = binarize(img[i:i+ksize[0], j:j+ksize[1]], th)

    return image_new

def get_best_threshold(img):
    resolution = 100
    img_px = img.reshape(-1)
    hist = np.zeros(resolution)
    hist_tmp = 0
    for i in range(resolution):
        # hist[i] is the number of pixels whose value is in i/100 and (i+1)/100
        if i == 99:
            val = np.where((img_px >= i/resolution) & (img_px <= (i+1)/resolution))[0]
        else:
            val = np.where((img_px >= i/resolution) & (img_px < (i+1)/resolution))[0]
        
        hist[i] = np.sum(img_px[val])

    # plt.plot(hist)
    # plt.show()

    _, hist_mass_center = get_mass_center(hist, 0, resolution)
    last_th = hist_mass_center

    while True:
        _, hist_mass_center_left = get_mass_center(hist, 0, int(last_th))
        _, hist_mass_center_right = get_mass_center(hist, int(last_th), resolution)
        hist_mass_center = (hist_mass_center_left + hist_mass_center_right)/2
        if np.abs(hist_mass_center - last_th) < 0.01:
            return hist_mass_center/resolution
        else:
            last_th = hist_mass_center


def get_mass_center(f, a, b):
    # return integral(i*f,a,b)/integral(f,a,b)
    area = 0
    area_tmp = 0
    for i in range(a, b):
        area += f[i]
        area_tmp += i*f[i]
    
    # 1e-8 is to avoid division by zero
    return area, area_tmp/(area+1e-8)

def resize(image, size, order='cv2'):
    if order == 'cv2':
        size = (size[1], size[0])
    new_height, new_width = size
    new_image = np.zeros((new_height, new_width), image.dtype)  # new_image = [[0 for _ in range(new_width)] for _ in range(new_height)]

    orig_height = image.shape[0]
    orig_width = image.shape[1]

    # Compute center column and center row
    x_orig_center = (orig_width-1) / 2
    y_orig_center = (orig_height-1) / 2

    # Compute center of resized image
    x_scaled_center = (new_width-1) / 2
    y_scaled_center = (new_height-1) / 2

    # Compute the scale in both axes
    scale_x = orig_width / new_width
    scale_y = orig_height / new_height

    # generated by AI, have no idea how it works :(
    y_indices, x_indices = np.indices(new_image.shape)
    y_ = (y_indices - y_scaled_center) * scale_y + y_orig_center
    x_ = (x_indices - x_scaled_center) * scale_x + x_orig_center

    # Bilinear interpolation (generated by AI)
    x_floor = np.floor(x_).astype(int)
    y_floor = np.floor(y_).astype(int)
    x_ceil = x_floor + 1
    y_ceil = y_floor + 1

    x_floor = np.clip(x_floor, 0, orig_width - 1)
    x_ceil = np.clip(x_ceil, 0, orig_width - 1)
    y_floor = np.clip(y_floor, 0, orig_height - 1)
    y_ceil = np.clip(y_ceil, 0, orig_height - 1)

    Q11 = image[y_floor, x_floor]
    Q12 = image[y_ceil, x_floor]
    Q21 = image[y_floor, x_ceil]
    Q22 = image[y_ceil, x_ceil]

    x_diff = x_ - x_floor
    y_diff = y_ - y_floor

    new_image = (Q11 * (1 - x_diff) * (1 - y_diff) +
                 Q21 * x_diff * (1 - y_diff) +
                 Q12 * (1 - x_diff) * y_diff +
                 Q22 * x_diff * y_diff).astype(image.dtype)

    return new_image